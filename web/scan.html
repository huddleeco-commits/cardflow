<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>CardFlow Scanner</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: #000;
      color: #fff;
      height: 100vh;
      height: 100dvh;
      overflow: hidden;
      touch-action: manipulation;
      -webkit-user-select: none;
      user-select: none;
    }

    .scanner {
      position: relative;
      width: 100%;
      height: 100%;
    }

    #video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .card-frame {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 70%;
      max-width: 280px;
      aspect-ratio: 2.5/3.5;
      border: 3px solid rgba(0, 246, 255, 0.7);
      border-radius: 12px;
      pointer-events: none;
      box-shadow: 0 0 0 9999px rgba(0,0,0,0.5);
    }

    .card-frame.back-mode {
      border-color: #7b2ff7;
    }

    .status-bar {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 16px 20px;
      background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 10;
    }

    .logo {
      font-size: 16px;
      font-weight: 700;
      background: linear-gradient(135deg, #00f6ff, #7b2ff7);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .connection {
      font-size: 11px;
      opacity: 0.7;
    }
    .connection.connected { color: #00ff88; }

    .mode-toggle {
      padding: 8px 16px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 20px;
      color: #fff;
      font-size: 11px;
      cursor: pointer;
    }
    .mode-toggle.active {
      background: rgba(0, 246, 255, 0.2);
      border-color: #00f6ff;
      color: #00f6ff;
    }

    /* Voice control */
    .voice-btn {
      padding: 8px 14px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 20px;
      color: #fff;
      font-size: 14px;
      cursor: pointer;
      margin-left: 8px;
    }
    .voice-btn.active {
      background: rgba(255, 59, 48, 0.3);
      border-color: #ff3b30;
      color: #ff3b30;
      animation: voicePulse 1.5s infinite;
    }
    @keyframes voicePulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(255, 59, 48, 0.4); }
      50% { box-shadow: 0 0 0 8px rgba(255, 59, 48, 0); }
    }

    .voice-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 16px 32px;
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #ff3b30;
      border-radius: 12px;
      font-size: 18px;
      font-weight: 600;
      color: #ff3b30;
      z-index: 50;
      display: none;
    }
    .voice-indicator.show { display: block; }

    /* State badge */
    .state-badge {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 32px;
      background: rgba(0,0,0,0.9);
      border-radius: 30px;
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 3px;
      z-index: 10;
      border: 2px solid #00f6ff;
      color: #00f6ff;
    }
    .state-badge.back {
      border-color: #7b2ff7;
      color: #7b2ff7;
    }

    /* Bulk mode info bar */
    .bulk-info {
      position: absolute;
      top: 140px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 20px;
      background: rgba(0,0,0,0.8);
      border-radius: 20px;
      font-size: 14px;
      z-index: 10;
      display: none;
    }
    .bulk-info.show { display: block; }
    .bulk-info .count {
      font-weight: 700;
      color: #00f6ff;
    }
    .bulk-info.back-phase .count {
      color: #7b2ff7;
    }

    /* Bottom controls */
    .bottom-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 20px;
      background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      z-index: 10;
    }

    .capture-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: #fff;
      border: 4px solid rgba(255,255,255,0.3);
      cursor: pointer;
      transition: transform 0.1s;
      position: relative;
    }
    .capture-btn:active {
      transform: scale(0.9);
      background: #00f6ff;
    }
    .capture-btn::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: 3px solid rgba(0,0,0,0.3);
    }

    .side-info {
      text-align: center;
      min-width: 70px;
    }
    .side-info .value {
      font-size: 28px;
      font-weight: 700;
    }
    .side-info .label {
      font-size: 10px;
      opacity: 0.6;
      text-transform: uppercase;
    }

    /* Done button for bulk mode */
    .done-btn {
      position: absolute;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      padding: 14px 40px;
      background: linear-gradient(135deg, #00f6ff, #7b2ff7);
      border: none;
      border-radius: 30px;
      color: #fff;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      z-index: 20;
      display: none;
    }
    .done-btn.show { display: block; }

    /* Login screen */
    .login-screen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #0a0e1a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 200;
    }
    .login-screen h1 {
      font-size: 32px;
      margin-bottom: 8px;
      background: linear-gradient(135deg, #00f6ff, #7b2ff7);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .login-screen p { opacity: 0.6; margin-bottom: 32px; }
    .login-screen input {
      width: 100%;
      max-width: 300px;
      padding: 16px;
      margin-bottom: 12px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      color: #fff;
      font-size: 16px;
    }
    .login-screen button {
      width: 100%;
      max-width: 300px;
      padding: 16px;
      background: linear-gradient(135deg, #00f6ff, #7b2ff7);
      border: none;
      border-radius: 8px;
      color: #fff;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
    }

    .flash {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #fff;
      opacity: 0;
      pointer-events: none;
      z-index: 100;
    }
    .flash.show {
      animation: flashAnim 0.15s;
    }
    @keyframes flashAnim {
      0% { opacity: 0.7; }
      100% { opacity: 0; }
    }

    #canvas { display: none; }

    /* Zoom slider */
    .zoom-slider-container {
      position: absolute;
      right: 16px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 15;
      display: none;
    }
    .zoom-slider-container.show { display: flex; }
    .zoom-label {
      font-size: 11px;
      font-weight: 600;
      color: #00f6ff;
      margin-bottom: 6px;
    }
    .zoom-slider {
      -webkit-appearance: none;
      appearance: none;
      width: 140px;
      height: 4px;
      background: rgba(255,255,255,0.2);
      border-radius: 2px;
      outline: none;
      transform: rotate(-90deg);
      transform-origin: center center;
    }
    .zoom-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #00f6ff;
      cursor: pointer;
      box-shadow: 0 0 6px rgba(0,246,255,0.5);
    }

    /* Focus ring */
    .focus-ring {
      position: absolute;
      width: 60px;
      height: 60px;
      border: 2px solid #00f6ff;
      border-radius: 50%;
      pointer-events: none;
      z-index: 12;
      transform: translate(-50%, -50%);
      animation: focusRingAnim 0.8s ease-out forwards;
    }
    @keyframes focusRingAnim {
      0% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
      20% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      80% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
    }

    /* Blur warning toast */
    .blur-warning {
      position: absolute;
      bottom: 140px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 24px;
      background: rgba(255, 165, 0, 0.9);
      color: #000;
      font-size: 13px;
      font-weight: 600;
      border-radius: 20px;
      z-index: 25;
      pointer-events: none;
      animation: fadeInOut 2s ease-in-out forwards;
    }
    @keyframes fadeInOut {
      0% { opacity: 0; transform: translateX(-50%) translateY(8px); }
      15% { opacity: 1; transform: translateX(-50%) translateY(0); }
      75% { opacity: 1; transform: translateX(-50%) translateY(0); }
      100% { opacity: 0; transform: translateX(-50%) translateY(-8px); }
    }

    /* Deskew toggle */
    .deskew-toggle {
      padding: 6px 12px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 16px;
      color: #fff;
      font-size: 10px;
      cursor: pointer;
      margin-left: 8px;
    }
    .deskew-toggle.active {
      background: rgba(0, 246, 255, 0.2);
      border-color: #00f6ff;
      color: #00f6ff;
    }

    /* Tutorial Modal */
    .tutorial-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.95);
      z-index: 300;
      display: none;
      overflow-y: auto;
      padding: 20px;
    }
    .tutorial-overlay.show { display: block; }

    .tutorial-content {
      max-width: 400px;
      margin: 0 auto;
      padding-bottom: 40px;
    }

    .tutorial-header {
      text-align: center;
      margin-bottom: 24px;
    }
    .tutorial-header h2 {
      font-size: 24px;
      background: linear-gradient(135deg, #7b2ff7, #00f6ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 8px;
    }
    .tutorial-header p {
      opacity: 0.7;
      font-size: 14px;
    }

    .tutorial-close {
      position: absolute;
      top: 16px;
      right: 16px;
      background: rgba(255,255,255,0.1);
      border: none;
      color: #fff;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
    }

    .tutorial-step {
      background: rgba(255,255,255,0.05);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 16px;
      position: relative;
    }

    .step-number {
      position: absolute;
      top: -10px;
      left: 20px;
      background: linear-gradient(135deg, #7b2ff7, #00f6ff);
      color: #000;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 14px;
    }

    .step-title {
      font-weight: 600;
      font-size: 16px;
      margin-bottom: 12px;
      margin-top: 8px;
    }

    .step-visual {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      margin: 16px 0;
      padding: 16px;
      background: rgba(0,0,0,0.3);
      border-radius: 12px;
    }

    .card-stack {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }
    .card-stack-label {
      font-size: 10px;
      opacity: 0.6;
      text-transform: uppercase;
    }
    .stack-cards {
      position: relative;
      width: 40px;
      height: 56px;
    }
    .mini-card {
      position: absolute;
      width: 36px;
      height: 50px;
      border-radius: 4px;
      border: 2px solid;
    }
    .mini-card.back {
      background: linear-gradient(135deg, #7b2ff7, #5a1fd6);
      border-color: #7b2ff7;
    }
    .mini-card.front {
      background: linear-gradient(135deg, #00f6ff, #00c4cc);
      border-color: #00f6ff;
    }
    .stack-cards .mini-card:nth-child(1) { top: 0; left: 0; }
    .stack-cards .mini-card:nth-child(2) { top: 3px; left: 3px; }
    .stack-cards .mini-card:nth-child(3) { top: 6px; left: 6px; }

    .scan-area {
      width: 50px;
      height: 70px;
      border: 2px dashed rgba(255,255,255,0.3);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .scan-area-icon {
      font-size: 20px;
      opacity: 0.5;
    }

    .arrow {
      font-size: 20px;
      opacity: 0.5;
    }

    .step-desc {
      font-size: 13px;
      opacity: 0.8;
      line-height: 1.5;
    }

    .flip-animation {
      display: flex;
      align-items: center;
      gap: 16px;
      justify-content: center;
    }
    .flip-arrow {
      font-size: 24px;
      animation: flipPulse 1s infinite;
    }
    @keyframes flipPulse {
      0%, 100% { transform: scaleX(1); opacity: 0.5; }
      50% { transform: scaleX(1.2); opacity: 1; }
    }

    .tutorial-tip {
      background: rgba(0, 246, 255, 0.1);
      border: 1px solid rgba(0, 246, 255, 0.3);
      border-radius: 12px;
      padding: 16px;
      margin-top: 24px;
    }
    .tutorial-tip-title {
      color: #00f6ff;
      font-weight: 600;
      margin-bottom: 8px;
      font-size: 14px;
    }
    .tutorial-tip p {
      font-size: 13px;
      opacity: 0.8;
      margin: 0;
    }

    .tutorial-start-btn {
      width: 100%;
      padding: 16px;
      background: linear-gradient(135deg, #7b2ff7, #00f6ff);
      border: none;
      border-radius: 12px;
      color: #fff;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      margin-top: 24px;
    }

    .help-btn {
      padding: 8px 12px;
      background: rgba(123, 47, 247, 0.2);
      border: 1px solid rgba(123, 47, 247, 0.4);
      border-radius: 20px;
      color: #7b2ff7;
      font-size: 11px;
      cursor: pointer;
      margin-left: 8px;
    }

    .mode-toggle.backs-first {
      background: rgba(123, 47, 247, 0.2);
      border-color: #7b2ff7;
      color: #7b2ff7;
    }

    /* Set Selection Screen */
    .set-selection-screen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #0a0e1a;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 24px;
      z-index: 190;
      overflow-y: auto;
    }
    .set-selection-screen h2 {
      font-size: 22px;
      font-weight: 700;
      background: linear-gradient(135deg, #00f6ff, #7b2ff7);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-top: 60px;
      margin-bottom: 8px;
    }
    .set-selection-screen .subtitle {
      color: rgba(255,255,255,0.5);
      font-size: 13px;
      margin-bottom: 24px;
    }
    .set-search-box {
      width: 100%;
      max-width: 400px;
      position: relative;
    }
    .set-search-box input {
      width: 100%;
      padding: 14px 16px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(255,255,255,0.08);
      color: #fff;
      font-size: 16px;
      outline: none;
    }
    .set-search-box input:focus {
      border-color: #00f6ff;
    }
    .set-search-box input::placeholder { color: rgba(255,255,255,0.35); }
    .set-results {
      width: 100%;
      max-width: 400px;
      margin-top: 8px;
      max-height: 300px;
      overflow-y: auto;
    }
    .set-result-item {
      padding: 12px 16px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      margin-bottom: 6px;
      cursor: pointer;
      transition: background 0.15s;
    }
    .set-result-item:active,
    .set-result-item:hover {
      background: rgba(0, 246, 255, 0.1);
      border-color: rgba(0, 246, 255, 0.3);
    }
    .set-result-name {
      font-weight: 600;
      font-size: 15px;
    }
    .set-result-meta {
      font-size: 12px;
      color: rgba(255,255,255,0.45);
      margin-top: 2px;
    }
    .set-confirm-card {
      width: 100%;
      max-width: 400px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(0, 246, 255, 0.3);
      border-radius: 14px;
      padding: 20px;
      margin-top: 16px;
    }
    .set-confirm-card h3 {
      font-size: 17px;
      margin-bottom: 4px;
    }
    .set-confirm-card .year-sport {
      font-size: 13px;
      color: rgba(255,255,255,0.45);
      margin-bottom: 12px;
    }
    .parallel-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 16px;
    }
    .parallel-tag {
      padding: 4px 10px;
      background: rgba(0, 246, 255, 0.1);
      border: 1px solid rgba(0, 246, 255, 0.25);
      border-radius: 20px;
      font-size: 11px;
      color: #00f6ff;
    }
    .set-actions {
      display: flex;
      gap: 12px;
      width: 100%;
      max-width: 400px;
      margin-top: 20px;
    }
    .set-actions button {
      flex: 1;
      padding: 14px;
      border-radius: 12px;
      border: none;
      font-size: 15px;
      font-weight: 700;
      cursor: pointer;
    }
    .btn-skip {
      background: rgba(255,255,255,0.1);
      color: rgba(255,255,255,0.6);
      border: 1px solid rgba(255,255,255,0.15) !important;
    }
    .btn-start-scanning {
      background: linear-gradient(135deg, #00f6ff, #7b2ff7);
      color: #000;
    }
    .btn-start-scanning:disabled {
      opacity: 0.4;
      cursor: default;
    }
    .set-search-loading {
      text-align: center;
      padding: 16px;
      color: rgba(255,255,255,0.4);
      font-size: 13px;
    }

    /* Popular sets grid */
    .set-popular {
      width: 100%;
      max-width: 400px;
      margin-top: 16px;
    }
    .set-popular-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .set-popular-btn {
      padding: 10px 16px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px;
      color: #fff;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }
    .set-popular-btn:active {
      background: rgba(0, 246, 255, 0.15);
      border-color: rgba(0, 246, 255, 0.4);
      color: #00f6ff;
    }

    /* Set badge on scanner */
    .set-badge {
      position: absolute;
      top: 56px;
      left: 50%;
      transform: translateX(-50%);
      padding: 5px 14px;
      background: rgba(0, 246, 255, 0.15);
      border: 1px solid rgba(0, 246, 255, 0.4);
      border-radius: 20px;
      color: #00f6ff;
      font-size: 11px;
      font-weight: 600;
      z-index: 15;
      cursor: pointer;
      white-space: nowrap;
      max-width: 80%;
      overflow: hidden;
      text-overflow: ellipsis;
      display: none;
    }
  </style>
</head>
<body>
  <!-- Login -->
  <div class="login-screen" id="login-screen">
    <h1>CardFlow</h1>
    <p>Phone Scanner</p>
    <input type="email" id="login-email" placeholder="Email">
    <input type="password" id="login-password" placeholder="Password">
    <button onclick="doLogin()">Start Scanning</button>
  </div>

  <!-- Set Selection Screen -->
  <div class="set-selection-screen" id="set-selection-screen" style="display: none;">
    <h2>What set are you scanning?</h2>
    <p class="subtitle">Pre-selecting a set improves parallel detection accuracy</p>

    <div class="set-search-box">
      <input type="text" id="set-search-input" placeholder="Search sets... e.g. Topps Chrome" autocomplete="off">
    </div>

    <!-- Popular sets - always visible as quick picks -->
    <div class="set-popular" id="set-popular">
      <div style="font-size: 11px; color: rgba(255,255,255,0.35); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">Popular Sets</div>
      <div class="set-popular-grid" id="set-popular-grid"></div>
    </div>

    <div class="set-results" id="set-results"></div>

    <div class="set-confirm-card" id="set-confirm-card" style="display: none;">
      <h3 id="set-confirm-name"></h3>
      <div class="year-sport" id="set-confirm-meta"></div>
      <div class="parallel-tags" id="set-confirm-parallels"></div>
    </div>

    <div class="set-actions">
      <button class="btn-skip" onclick="skipSetSelection()">Skip</button>
      <button class="btn-start-scanning" id="btn-start-scanning" onclick="confirmSetSelection()" disabled>Start Scanning</button>
    </div>
  </div>

  <!-- Scanner -->
  <div class="scanner" id="scanner" style="display: none;">
    <video id="video" autoplay playsinline muted></video>
    <div class="card-frame" id="card-frame"></div>

    <!-- Zoom slider -->
    <div class="zoom-slider-container" id="zoom-slider-container">
      <span class="zoom-label" id="zoom-label">1.0x</span>
      <input type="range" class="zoom-slider" id="zoom-slider" min="1" max="5" step="0.1" value="1" oninput="setZoom(parseFloat(this.value))">
    </div>

    <!-- Set context badge -->
    <div class="set-badge" id="set-badge" onclick="openSetSelection()"></div>

    <div class="status-bar">
      <div>
        <div class="logo" style="display: flex; align-items: center; gap: 8px;"><img src="/cardflow-logo.jpg" alt="CardFlow" style="width: 24px; height: 24px; border-radius: 4px;">CARDFLOW</div>
        <div class="connection" id="connection">Connecting...</div>
      </div>
      <div style="display: flex; align-items: center;">
        <button class="mode-toggle" id="mode-toggle" onclick="toggleMode()">PAIR MODE</button>
        <button class="help-btn" id="help-btn" onclick="showTutorial()" style="display:none;">?</button>
        <button class="deskew-toggle" id="deskew-toggle" onclick="toggleDeskew()">DESKEW</button>
        <button class="voice-btn" id="voice-btn" onclick="toggleVoice()">ðŸŽ¤</button>
      </div>
    </div>

    <div class="voice-indicator" id="voice-indicator">Listening...</div>

    <div class="state-badge" id="state-badge">FRONT</div>

    <div class="bulk-info" id="bulk-info">
      <span class="count" id="bulk-count">0</span> fronts captured
    </div>

    <button class="done-btn" id="done-btn" onclick="finishFronts()">Done with Fronts â†’</button>

    <div class="bottom-bar">
      <div class="side-info">
        <div class="value" id="fronts-count">0</div>
        <div class="label">Fronts</div>
      </div>

      <button class="capture-btn" id="capture-btn" onclick="capture()"></button>

      <div class="side-info">
        <div class="value" id="cards-count">0</div>
        <div class="label">Cards</div>
      </div>
    </div>

    <div class="flash" id="flash"></div>
  </div>

  <!-- Backs First Tutorial -->
  <div class="tutorial-overlay" id="tutorial-overlay">
    <button class="tutorial-close" onclick="closeTutorial()">&times;</button>
    <div class="tutorial-content">
      <div class="tutorial-header">
        <h2>Backs First Mode</h2>
        <p>Scan backs first for better parallel detection</p>
      </div>

      <div class="tutorial-step">
        <div class="step-number">1</div>
        <div class="step-title">Stack cards face-down on LEFT</div>
        <div class="step-visual">
          <div class="card-stack">
            <div class="stack-cards">
              <div class="mini-card back"></div>
              <div class="mini-card back"></div>
              <div class="mini-card back"></div>
            </div>
            <div class="card-stack-label">Left Stack</div>
          </div>
          <div class="arrow">â†’</div>
          <div class="scan-area">
            <span class="scan-area-icon">ðŸ“·</span>
          </div>
          <div class="arrow">â†’</div>
          <div class="card-stack" style="opacity: 0.3;">
            <div class="stack-cards">
              <div class="mini-card back"></div>
            </div>
            <div class="card-stack-label">Right Stack</div>
          </div>
        </div>
        <div class="step-desc">Place your stack of cards with backs facing up on your left side.</div>
      </div>

      <div class="tutorial-step">
        <div class="step-number">2</div>
        <div class="step-title">Scan each BACK, move to RIGHT</div>
        <div class="step-visual">
          <div class="card-stack" style="opacity: 0.5;">
            <div class="stack-cards">
              <div class="mini-card back"></div>
              <div class="mini-card back"></div>
            </div>
            <div class="card-stack-label">Left</div>
          </div>
          <div class="arrow">â†’</div>
          <div class="scan-area" style="border-color: #7b2ff7;">
            <div class="mini-card back" style="position: relative; width: 30px; height: 42px;"></div>
          </div>
          <div class="arrow">â†’</div>
          <div class="card-stack">
            <div class="stack-cards">
              <div class="mini-card back"></div>
              <div class="mini-card back"></div>
            </div>
            <div class="card-stack-label">Right</div>
          </div>
        </div>
        <div class="step-desc">Take top card from left, scan the back, say "Next", place it face-down on the right stack. Repeat for all cards.</div>
      </div>

      <div class="tutorial-step">
        <div class="step-number">3</div>
        <div class="step-title">FLIP the right stack over</div>
        <div class="step-visual">
          <div class="flip-animation">
            <div class="card-stack">
              <div class="stack-cards">
                <div class="mini-card back"></div>
                <div class="mini-card back"></div>
                <div class="mini-card back"></div>
              </div>
              <div class="card-stack-label">Backs up</div>
            </div>
            <div class="flip-arrow">ðŸ”„</div>
            <div class="card-stack">
              <div class="stack-cards">
                <div class="mini-card front"></div>
                <div class="mini-card front"></div>
                <div class="mini-card front"></div>
              </div>
              <div class="card-stack-label">Fronts up</div>
            </div>
          </div>
        </div>
        <div class="step-desc">When all backs are scanned, tap "Done with Backs". Then flip the entire right stack so fronts face up. The order is preserved!</div>
      </div>

      <div class="tutorial-step">
        <div class="step-number">4</div>
        <div class="step-title">Scan each FRONT in same order</div>
        <div class="step-visual">
          <div class="card-stack">
            <div class="stack-cards">
              <div class="mini-card front"></div>
              <div class="mini-card front"></div>
              <div class="mini-card front"></div>
            </div>
            <div class="card-stack-label">Fronts</div>
          </div>
          <div class="arrow">â†’</div>
          <div class="scan-area" style="border-color: #00f6ff;">
            <div class="mini-card front" style="position: relative; width: 30px; height: 42px;"></div>
          </div>
          <div class="arrow">â†’</div>
          <div class="card-stack" style="opacity: 0.3;">
            <div class="stack-cards">
              <div class="mini-card front"></div>
            </div>
            <div class="card-stack-label">Done</div>
          </div>
        </div>
        <div class="step-desc">Scan fronts in the same order. System already knows the card from the back - now it identifies the parallel/color!</div>
      </div>

      <div class="tutorial-tip">
        <div class="tutorial-tip-title">ðŸ’¡ Why Backs First?</div>
        <p>Card backs contain definitive info (player, year, set, card number). By scanning backs first, the AI knows exactly what card it is, then focuses only on identifying the parallel type from the front (refractor, gold, prizm, etc.)</p>
      </div>

      <button class="tutorial-start-btn" onclick="closeTutorial(); setScanMode('backsFirst');">
        Start Backs First Scanning
      </button>
    </div>
  </div>

  <canvas id="canvas"></canvas>

  <script>
    const API_URL = window.location.origin + '/api';
    let token = localStorage.getItem('token');
    let ws = null;
    let video, canvas, ctx;
    let audioCtx = null;
    let frameRect = null;

    // Voice recognition
    let recognition = null;
    let voiceEnabled = false;

    // Mode: 'pair' (front-back-front-back), 'bulk' (all fronts, then all backs), 'backsFirst' (all backs, then all fronts)
    let scanMode = 'pair';

    // Pair mode state
    let pairPhase = 'front';
    let pairFrontBlob = null;

    // Bulk mode state
    let bulkPhase = 'fronts'; // 'fronts' or 'backs'
    let bulkFronts = []; // Array of blobs
    let bulkBacks = []; // Array of blobs
    let bulkIndex = 0; // Current back index

    // Backs First mode state
    let backsFirstPhase = 'backs'; // 'backs' or 'fronts'
    let backsFirstBacks = []; // Array of blobs (scanned first)
    let backsFirstFronts = []; // Array of blobs (scanned second)
    let backsFirstIndex = 0;

    let totalCards = 0;

    // Camera enhancement state
    let videoTrack = null;
    let zoomCapabilities = null;
    let currentZoom = 1;
    let autoDeskewEnabled = false;
    let initialPinchDistance = null;
    let pinchZoomStart = 1;

    // Set context state
    let selectedSetContext = null;
    let setSearchTimeout = null;

    if (token) {
      showSetSelection();
    }

    async function doLogin() {
      const email = document.getElementById('login-email').value;
      const password = document.getElementById('login-password').value;

      try {
        const res = await fetch(`${API_URL}/auth/login`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ email, password })
        });
        const data = await res.json();

        if (data.token) {
          token = data.token;
          localStorage.setItem('token', token);
          showSetSelection();
        } else {
          alert(data.error || 'Login failed');
        }
      } catch (e) {
        alert('Login failed');
      }
    }

    async function initScanner() {
      document.getElementById('login-screen').style.display = 'none';
      document.getElementById('set-selection-screen').style.display = 'none';
      document.getElementById('scanner').style.display = 'block';

      // Show set badge if a set was selected
      const badge = document.getElementById('set-badge');
      if (selectedSetContext) {
        badge.textContent = (selectedSetContext.year ? selectedSetContext.year + ' ' : '') + selectedSetContext.set_name;
        badge.style.display = 'block';
      } else {
        badge.style.display = 'none';
      }

      video = document.getElementById('video');
      canvas = document.getElementById('canvas');
      ctx = canvas.getContext('2d');

      document.body.addEventListener('click', initAudio, { once: true });
      document.body.addEventListener('touchstart', initAudio, { once: true });

      await startCamera();
      connectWS();

      video.addEventListener('loadedmetadata', calculateFrameRect);
      window.addEventListener('resize', calculateFrameRect);

      updateUI();
    }

    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      // Resume if suspended (required on iOS/mobile)
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    }

    async function startCamera() {
      try {
        // Request highest quality camera settings
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'environment',
            width: { ideal: 3840, min: 1920 },  // 4K ideal, 1080p minimum
            height: { ideal: 2160, min: 1080 },
            frameRate: { ideal: 30 },
            // Advanced constraints for better quality
            focusMode: { ideal: 'continuous' },
            exposureMode: { ideal: 'continuous' },
            whiteBalanceMode: { ideal: 'continuous' }
          }
        });
        video.srcObject = stream;
        await video.play();

        // Store track reference and check zoom capabilities
        videoTrack = stream.getVideoTracks()[0];
        initZoomCapabilities();

        // Log actual resolution
        console.log(`Camera resolution: ${video.videoWidth}x${video.videoHeight}`);
      } catch (e) {
        // Fallback to basic settings if advanced constraints fail
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: 'environment',
              width: { ideal: 1920 },
              height: { ideal: 1080 }
            }
          });
          video.srcObject = stream;
          await video.play();

          videoTrack = stream.getVideoTracks()[0];
          initZoomCapabilities();
        } catch (e2) {
          alert('Camera access required');
        }
      }
    }

    function initZoomCapabilities() {
      const slider = document.getElementById('zoom-slider');
      const container = document.getElementById('zoom-slider-container');

      if (videoTrack && typeof videoTrack.getCapabilities === 'function') {
        const caps = videoTrack.getCapabilities();
        if (caps.zoom) {
          zoomCapabilities = { min: caps.zoom.min, max: caps.zoom.max, type: 'hardware' };
          slider.min = caps.zoom.min;
          slider.max = caps.zoom.max;
          slider.step = (caps.zoom.max - caps.zoom.min) / 50;
          slider.value = caps.zoom.min;
          currentZoom = caps.zoom.min;
          container.classList.add('show');
          console.log(`Hardware zoom: ${caps.zoom.min}-${caps.zoom.max}`);
          return;
        }
      }

      // Digital zoom fallback
      zoomCapabilities = { min: 1, max: 5, type: 'digital' };
      slider.min = 1;
      slider.max = 5;
      slider.step = 0.1;
      slider.value = 1;
      currentZoom = 1;
      container.classList.add('show');
      console.log('Using digital zoom fallback');
    }

    function calculateFrameRect() {
      const frame = document.getElementById('card-frame');
      const frameBox = frame.getBoundingClientRect();
      const videoBox = video.getBoundingClientRect();

      const scaleX = video.videoWidth / videoBox.width;
      const scaleY = video.videoHeight / videoBox.height;

      frameRect = {
        x: (frameBox.left - videoBox.left) * scaleX,
        y: (frameBox.top - videoBox.top) * scaleY,
        width: frameBox.width * scaleX,
        height: frameBox.height * scaleY
      };

      canvas.width = frameRect.width;
      canvas.height = frameRect.height;
    }

    function connectWS() {
      const wsProto = location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${wsProto}//${location.host}`);

      ws.onopen = () => {
        document.getElementById('connection').textContent = 'Connected';
        document.getElementById('connection').classList.add('connected');
        ws.send(JSON.stringify({ type: 'auth', token }));
      };

      ws.onclose = () => {
        document.getElementById('connection').textContent = 'Reconnecting...';
        document.getElementById('connection').classList.remove('connected');
        setTimeout(connectWS, 2000);
      };
    }

    function toggleMode() {
      if (scanMode === 'pair') {
        scanMode = 'bulk';
        bulkPhase = 'fronts';
        bulkFronts = [];
        bulkBacks = [];
        bulkIndex = 0;
      } else if (scanMode === 'bulk') {
        scanMode = 'backsFirst';
        backsFirstPhase = 'backs';
        backsFirstBacks = [];
        backsFirstFronts = [];
        backsFirstIndex = 0;
      } else {
        scanMode = 'pair';
        pairPhase = 'front';
        pairFrontBlob = null;
      }
      updateUI();
    }

    function setScanMode(mode) {
      scanMode = mode;
      if (mode === 'backsFirst') {
        backsFirstPhase = 'backs';
        backsFirstBacks = [];
        backsFirstFronts = [];
        backsFirstIndex = 0;
      }
      updateUI();
    }

    function showTutorial() {
      document.getElementById('tutorial-overlay').classList.add('show');
    }

    function closeTutorial() {
      document.getElementById('tutorial-overlay').classList.remove('show');
    }

    async function capture() {
      if (!frameRect) calculateFrameRect();

      // Flash
      const flash = document.getElementById('flash');
      flash.classList.add('show');
      setTimeout(() => flash.classList.remove('show'), 150);

      // Adjust crop for digital zoom
      let sx = frameRect.x, sy = frameRect.y, sw = frameRect.width, sh = frameRect.height;
      if (zoomCapabilities && zoomCapabilities.type === 'digital' && currentZoom > 1) {
        const cx = video.videoWidth / 2;
        const cy = video.videoHeight / 2;
        const zoomedW = video.videoWidth / currentZoom;
        const zoomedH = video.videoHeight / currentZoom;
        const offsetX = cx - zoomedW / 2;
        const offsetY = cy - zoomedH / 2;

        const videoBox = video.getBoundingClientRect();
        const scaleX = video.videoWidth / videoBox.width;
        const scaleY = video.videoHeight / videoBox.height;
        const frameEl = document.getElementById('card-frame');
        const frameBox = frameEl.getBoundingClientRect();

        sx = offsetX + (frameBox.left - videoBox.left) * scaleX / currentZoom;
        sy = offsetY + (frameBox.top - videoBox.top) * scaleY / currentZoom;
        sw = frameBox.width * scaleX / currentZoom;
        sh = frameBox.height * scaleY / currentZoom;
      }

      // Capture cropped frame
      canvas.width = frameRect.width;
      canvas.height = frameRect.height;
      ctx.drawImage(video, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height);

      // Auto-deskew if enabled
      if (autoDeskewEnabled) {
        const angle = detectSkewAngle(canvas);
        if (Math.abs(angle) >= 0.5 && Math.abs(angle) <= 15) {
          deskewImage(canvas, angle);
        }
      }

      const blob = await new Promise(r => canvas.toBlob(r, 'image/jpeg', 0.95));

      // Non-blocking blur detection
      const capturedCanvas = document.createElement('canvas');
      capturedCanvas.width = canvas.width;
      capturedCanvas.height = canvas.height;
      capturedCanvas.getContext('2d').drawImage(canvas, 0, 0);
      requestAnimationFrame(() => {
        if (detectBlur(capturedCanvas)) {
          showBlurWarning();
        }
      });

      if (scanMode === 'pair') {
        await capturePairMode(blob);
      } else if (scanMode === 'bulk') {
        await captureBulkMode(blob);
      } else if (scanMode === 'backsFirst') {
        await captureBacksFirstMode(blob);
      }

      updateUI();
    }

    async function capturePairMode(blob) {
      if (pairPhase === 'front') {
        pairFrontBlob = blob;
        playSound('front');
        pairPhase = 'back';
      } else {
        playSound('back');
        await uploadPair(pairFrontBlob, blob);
        playSound('complete');
        totalCards++;
        pairPhase = 'front';
        pairFrontBlob = null;
      }
    }

    async function captureBulkMode(blob) {
      if (bulkPhase === 'fronts') {
        bulkFronts.push(blob);
        playSound('front');
      } else {
        bulkBacks.push(blob);
        playSound('back');
        bulkIndex++;

        // If we have all backs, upload them all
        if (bulkBacks.length === bulkFronts.length) {
          await uploadAllPairs();
        }
      }
    }

    function finishFronts() {
      if (bulkFronts.length === 0) {
        alert('Capture at least one front first');
        return;
      }
      bulkPhase = 'backs';
      bulkIndex = 0;
      playSound('complete');
      updateUI();
    }

    // Backs First Mode functions
    async function captureBacksFirstMode(blob) {
      if (backsFirstPhase === 'backs') {
        backsFirstBacks.push(blob);
        playSound('back');
      } else {
        backsFirstFronts.push(blob);
        playSound('front');
        backsFirstIndex++;

        // If we have all fronts, upload them all
        if (backsFirstFronts.length === backsFirstBacks.length) {
          await uploadAllBacksFirstPairs();
        }
      }
    }

    function finishBacks() {
      if (backsFirstBacks.length === 0) {
        alert('Capture at least one back first');
        return;
      }
      backsFirstPhase = 'fronts';
      backsFirstIndex = 0;
      playSound('complete');
      updateUI();
    }

    async function uploadAllBacksFirstPairs() {
      playSound('complete');

      for (let i = 0; i < backsFirstBacks.length; i++) {
        // Note: front and back are swapped in array order but uploaded correctly
        await uploadPair(backsFirstFronts[i], backsFirstBacks[i]);
        totalCards++;
      }

      // Reset backs first mode
      backsFirstBacks = [];
      backsFirstFronts = [];
      backsFirstPhase = 'backs';
      backsFirstIndex = 0;
      updateUI();
    }

    async function uploadAllPairs() {
      playSound('complete');

      for (let i = 0; i < bulkFronts.length; i++) {
        await uploadPair(bulkFronts[i], bulkBacks[i]);
        totalCards++;
      }

      // Reset bulk mode
      bulkFronts = [];
      bulkBacks = [];
      bulkPhase = 'fronts';
      bulkIndex = 0;
      updateUI();
    }

    async function uploadPair(front, back) {
      const formData = new FormData();
      formData.append('front', front, 'front.jpg');
      formData.append('back', back, 'back.jpg');
      formData.append('batch', 'true');
      formData.append('source', 'phone');
      if (selectedSetContext) formData.append('set_context', JSON.stringify(selectedSetContext));

      try {
        const res = await fetch(`${API_URL}/upload-pair`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}` },
          body: formData
        });
        const data = await res.json();

        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'batch_card', cardId: data.cardId }));
        }
      } catch (e) {
        playSound('error');
      }
    }

    function updateUI() {
      const badge = document.getElementById('state-badge');
      const modeBtn = document.getElementById('mode-toggle');
      const bulkInfo = document.getElementById('bulk-info');
      const doneBtn = document.getElementById('done-btn');
      const cardFrame = document.getElementById('card-frame');
      const helpBtn = document.getElementById('help-btn');

      // Update mode button text and style
      if (scanMode === 'pair') {
        modeBtn.textContent = 'PAIR MODE';
        modeBtn.classList.remove('active', 'backs-first');
      } else if (scanMode === 'bulk') {
        modeBtn.textContent = 'BULK MODE';
        modeBtn.classList.add('active');
        modeBtn.classList.remove('backs-first');
      } else if (scanMode === 'backsFirst') {
        modeBtn.textContent = 'BACKS FIRST';
        modeBtn.classList.remove('active');
        modeBtn.classList.add('backs-first');
      }

      // Show help button only for backsFirst mode
      helpBtn.style.display = scanMode === 'backsFirst' ? 'inline-block' : 'none';

      if (scanMode === 'pair') {
        badge.textContent = pairPhase.toUpperCase();
        badge.classList.toggle('back', pairPhase === 'back');
        cardFrame.classList.toggle('back-mode', pairPhase === 'back');
        bulkInfo.classList.remove('show');
        doneBtn.classList.remove('show');
        document.getElementById('fronts-count').textContent = pairPhase === 'back' ? '1' : '0';
      } else if (scanMode === 'bulk') {
        if (bulkPhase === 'fronts') {
          badge.textContent = 'FRONTS';
          badge.classList.remove('back');
          cardFrame.classList.remove('back-mode');
          bulkInfo.classList.add('show');
          bulkInfo.classList.remove('back-phase');
          bulkInfo.innerHTML = `<span class="count">${bulkFronts.length}</span> fronts captured`;
          doneBtn.classList.toggle('show', bulkFronts.length > 0);
          doneBtn.textContent = `Done with Fronts (${bulkFronts.length}) â†’`;
          doneBtn.onclick = finishFronts;
          document.getElementById('fronts-count').textContent = bulkFronts.length;
        } else {
          badge.textContent = `BACK ${bulkBacks.length + 1}/${bulkFronts.length}`;
          badge.classList.add('back');
          cardFrame.classList.add('back-mode');
          bulkInfo.classList.add('show', 'back-phase');
          bulkInfo.innerHTML = `<span class="count">${bulkBacks.length}/${bulkFronts.length}</span> backs captured`;
          doneBtn.classList.remove('show');
          document.getElementById('fronts-count').textContent = bulkFronts.length;
        }
      } else if (scanMode === 'backsFirst') {
        if (backsFirstPhase === 'backs') {
          badge.textContent = 'BACKS';
          badge.classList.add('back');
          cardFrame.classList.add('back-mode');
          bulkInfo.classList.add('show');
          bulkInfo.classList.add('back-phase');
          bulkInfo.innerHTML = `<span class="count">${backsFirstBacks.length}</span> backs captured`;
          doneBtn.classList.toggle('show', backsFirstBacks.length > 0);
          doneBtn.textContent = `Done with Backs (${backsFirstBacks.length}) â†’ Flip & Scan Fronts`;
          doneBtn.onclick = finishBacks;
          document.getElementById('fronts-count').textContent = '0';
        } else {
          badge.textContent = `FRONT ${backsFirstFronts.length + 1}/${backsFirstBacks.length}`;
          badge.classList.remove('back');
          cardFrame.classList.remove('back-mode');
          bulkInfo.classList.add('show');
          bulkInfo.classList.remove('back-phase');
          bulkInfo.innerHTML = `<span class="count">${backsFirstFronts.length}/${backsFirstBacks.length}</span> fronts captured`;
          doneBtn.classList.remove('show');
          document.getElementById('fronts-count').textContent = backsFirstFronts.length;
        }
      }

      document.getElementById('cards-count').textContent = totalCards;
    }

    function playSound(type) {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }

      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      gain.gain.value = 0.3;

      if (type === 'front') {
        osc.frequency.value = 880;
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
      } else if (type === 'back') {
        osc.frequency.value = 988;
        osc.start();
        osc.stop(audioCtx.currentTime + 0.08);
        setTimeout(() => {
          const o2 = audioCtx.createOscillator();
          const g2 = audioCtx.createGain();
          o2.connect(g2);
          g2.connect(audioCtx.destination);
          g2.gain.value = 0.3;
          o2.frequency.value = 988;
          o2.start();
          o2.stop(audioCtx.currentTime + 0.08);
        }, 100);
      } else if (type === 'complete') {
        osc.frequency.setValueAtTime(523, audioCtx.currentTime);
        osc.frequency.linearRampToValueAtTime(784, audioCtx.currentTime + 0.1);
        osc.frequency.linearRampToValueAtTime(1047, audioCtx.currentTime + 0.2);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.3);
      } else if (type === 'error') {
        osc.frequency.value = 200;
        osc.type = 'sawtooth';
        gain.gain.value = 0.15;
        osc.start();
        osc.stop(audioCtx.currentTime + 0.25);
      }
    }

    // Pinch-to-zoom and tap-to-focus on video area
    document.addEventListener('touchstart', e => {
      if (e.touches.length === 2) {
        e.preventDefault();
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        initialPinchDistance = Math.hypot(dx, dy);
        pinchZoomStart = currentZoom;
      } else if (e.touches.length === 1) {
        const t = e.target;
        if (t === video || t.closest('.scanner')) {
          handleTapToFocus(e.touches[0]);
        }
      }
    }, { passive: false });

    document.addEventListener('touchmove', e => {
      if (e.touches.length === 2 && initialPinchDistance) {
        e.preventDefault();
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.hypot(dx, dy);
        const scale = dist / initialPinchDistance;
        const min = zoomCapabilities ? zoomCapabilities.min : 1;
        const max = zoomCapabilities ? zoomCapabilities.max : 5;
        const newZoom = Math.min(max, Math.max(min, pinchZoomStart * scale));
        setZoom(newZoom);
        document.getElementById('zoom-slider').value = newZoom;
      }
    }, { passive: false });

    document.addEventListener('touchend', e => {
      if (e.touches.length < 2) {
        initialPinchDistance = null;
      }
    });

    // --- Zoom ---
    function setZoom(value) {
      currentZoom = value;
      document.getElementById('zoom-label').textContent = value.toFixed(1) + 'x';

      if (zoomCapabilities && zoomCapabilities.type === 'hardware' && videoTrack) {
        try {
          videoTrack.applyConstraints({ advanced: [{ zoom: value }] });
        } catch (e) {
          console.log('Hardware zoom failed, falling back to digital');
          zoomCapabilities.type = 'digital';
          applyDigitalZoom(value);
        }
      } else {
        applyDigitalZoom(value);
      }
    }

    function applyDigitalZoom(value) {
      video.style.transform = `scale(${value})`;
      video.style.transformOrigin = 'center center';
    }

    function toggleDeskew() {
      autoDeskewEnabled = !autoDeskewEnabled;
      const btn = document.getElementById('deskew-toggle');
      btn.classList.toggle('active', autoDeskewEnabled);
    }

    // --- Tap-to-Focus ---
    function handleTapToFocus(touch) {
      const videoBox = video.getBoundingClientRect();
      const x = (touch.clientX - videoBox.left) / videoBox.width;
      const y = (touch.clientY - videoBox.top) / videoBox.height;

      // Only process taps inside the video area
      if (x < 0 || x > 1 || y < 0 || y > 1) return;

      showFocusRing(touch.clientX, touch.clientY);

      if (videoTrack && typeof videoTrack.getCapabilities === 'function') {
        const caps = videoTrack.getCapabilities();
        if (caps.focusMode && caps.focusMode.includes('manual')) {
          try {
            videoTrack.applyConstraints({
              focusMode: 'manual',
              pointsOfInterest: [{ x, y }]
            });

            // Return to continuous after 3s
            setTimeout(() => {
              try {
                videoTrack.applyConstraints({ focusMode: 'continuous' });
              } catch (e) {}
            }, 3000);
          } catch (e) {
            // Silent fail - continuous autofocus is fine
          }
        }
      }
    }

    function showFocusRing(x, y) {
      const ring = document.createElement('div');
      ring.className = 'focus-ring';
      ring.style.left = x + 'px';
      ring.style.top = y + 'px';
      document.querySelector('.scanner').appendChild(ring);
      ring.addEventListener('animationend', () => ring.remove());
    }

    // --- Blur Detection ---
    function detectBlur(cvs) {
      const w = cvs.width;
      const h = cvs.height;
      const c = cvs.getContext('2d');
      const imgData = c.getImageData(0, 0, w, h);
      const gray = new Float32Array(w * h);

      // Convert to grayscale
      for (let i = 0; i < w * h; i++) {
        const r = imgData.data[i * 4];
        const g = imgData.data[i * 4 + 1];
        const b = imgData.data[i * 4 + 2];
        gray[i] = 0.299 * r + 0.587 * g + 0.114 * b;
      }

      // Laplacian variance
      let sum = 0, sumSq = 0, count = 0;
      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          const lap = -4 * gray[y * w + x]
            + gray[(y - 1) * w + x]
            + gray[(y + 1) * w + x]
            + gray[y * w + (x - 1)]
            + gray[y * w + (x + 1)];
          sum += lap;
          sumSq += lap * lap;
          count++;
        }
      }

      const mean = sum / count;
      const variance = (sumSq / count) - (mean * mean);
      console.log('Blur variance:', variance.toFixed(1));
      return variance < 100; // Threshold for blur detection
    }

    function showBlurWarning() {
      const existing = document.querySelector('.blur-warning');
      if (existing) existing.remove();

      const warning = document.createElement('div');
      warning.className = 'blur-warning';
      warning.textContent = 'Image may be blurry';
      document.querySelector('.scanner').appendChild(warning);
      warning.addEventListener('animationend', () => warning.remove());
    }

    // --- Auto-Deskew ---
    function detectSkewAngle(cvs) {
      const w = cvs.width;
      const h = cvs.height;
      const c = cvs.getContext('2d');
      const imgData = c.getImageData(0, 0, w, h);
      const gray = new Float32Array(w * h);

      // Convert to grayscale
      for (let i = 0; i < w * h; i++) {
        gray[i] = 0.299 * imgData.data[i * 4] + 0.587 * imgData.data[i * 4 + 1] + 0.114 * imgData.data[i * 4 + 2];
      }

      // Sobel edge detection - compute gradient magnitudes and angles
      const angles = [];
      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          const gx = -gray[(y-1)*w+(x-1)] + gray[(y-1)*w+(x+1)]
                    - 2*gray[y*w+(x-1)] + 2*gray[y*w+(x+1)]
                    - gray[(y+1)*w+(x-1)] + gray[(y+1)*w+(x+1)];
          const gy = -gray[(y-1)*w+(x-1)] - 2*gray[(y-1)*w+x] - gray[(y-1)*w+(x+1)]
                    + gray[(y+1)*w+(x-1)] + 2*gray[(y+1)*w+x] + gray[(y+1)*w+(x+1)];
          const mag = Math.sqrt(gx * gx + gy * gy);

          if (mag > 50) { // Only strong edges
            let angle = Math.atan2(gy, gx) * (180 / Math.PI);
            // Normalize to -45..45 range (we care about near-horizontal/vertical edges)
            angle = ((angle % 90) + 90) % 90;
            if (angle > 45) angle -= 90;
            angles.push(angle);
          }
        }
      }

      if (angles.length < 100) return 0;

      // Angle histogram with 0.5-degree bins
      const bins = new Float32Array(180); // -45 to +45 in 0.5 degree steps
      for (const a of angles) {
        const bin = Math.round((a + 45) * 2);
        if (bin >= 0 && bin < 180) bins[bin]++;
      }

      // Find peak bin
      let peakBin = 0, peakVal = 0;
      for (let i = 0; i < 180; i++) {
        if (bins[i] > peakVal) {
          peakVal = bins[i];
          peakBin = i;
        }
      }

      const dominantAngle = (peakBin / 2) - 45;
      console.log('Detected skew angle:', dominantAngle.toFixed(2));
      return dominantAngle;
    }

    function deskewImage(cvs, angle) {
      const w = cvs.width;
      const h = cvs.height;
      const c = cvs.getContext('2d');

      // Copy current image
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = w;
      tempCanvas.height = h;
      tempCanvas.getContext('2d').drawImage(cvs, 0, 0);

      // Rotate canvas
      c.clearRect(0, 0, w, h);
      c.save();
      c.translate(w / 2, h / 2);
      c.rotate(-angle * Math.PI / 180);
      c.drawImage(tempCanvas, -w / 2, -h / 2);
      c.restore();
    }

    // Voice recognition setup
    function initVoiceRecognition() {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        alert('Voice commands not supported in this browser');
        return false;
      }

      recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = false;
      recognition.lang = 'en-US';

      recognition.onresult = (event) => {
        const last = event.results.length - 1;
        const command = event.results[last][0].transcript.toLowerCase().trim();
        handleVoiceCommand(command);
      };

      recognition.onerror = (event) => {
        console.log('Voice error:', event.error);
        // Restart on any error if still enabled
        if (voiceEnabled && event.error !== 'not-allowed') {
          setTimeout(() => {
            if (voiceEnabled) {
              try { recognition.start(); } catch(e) {}
            }
          }, 300);
        }
        if (event.error === 'not-allowed') {
          alert('Microphone access denied. Please allow microphone access and try again.');
          voiceEnabled = false;
          document.getElementById('voice-btn').classList.remove('active');
        }
      };

      recognition.onstart = () => {
        console.log('Voice recognition started');
        document.getElementById('voice-btn').textContent = 'ðŸ”´';
      };

      recognition.onend = () => {
        console.log('Voice recognition ended');
        // Restart if still enabled (recognition stops after periods of silence)
        if (voiceEnabled) {
          document.getElementById('voice-btn').textContent = 'ðŸŽ¤';
          setTimeout(() => {
            if (voiceEnabled) {
              try {
                recognition.start();
              } catch(e) {
                console.log('Restart failed:', e);
              }
            }
          }, 300);
        }
      };

      return true;
    }

    function toggleVoice() {
      if (!recognition && !initVoiceRecognition()) return;

      voiceEnabled = !voiceEnabled;
      const btn = document.getElementById('voice-btn');
      const indicator = document.getElementById('voice-indicator');

      if (voiceEnabled) {
        btn.classList.add('active');
        btn.textContent = 'ðŸ”´';
        indicator.textContent = 'Listening...';
        indicator.classList.add('show');
        setTimeout(() => indicator.classList.remove('show'), 1500);
        try {
          recognition.start();
        } catch(e) {
          console.log('Start error:', e);
        }
        playSound('front'); // Feedback beep
      } else {
        btn.classList.remove('active');
        btn.textContent = 'ðŸŽ¤';
        indicator.classList.remove('show');
        recognition.stop();
      }
    }

    function handleVoiceCommand(command) {
      console.log('Voice command:', command);
      const indicator = document.getElementById('voice-indicator');

      // Capture commands
      const captureWords = ['capture', 'next', 'snap', 'go', 'take', 'shoot', 'got it', 'got', 'front', 'back', 'yes', 'yep', 'okay', 'cap'];
      // Done commands (for bulk/backsFirst mode)
      const doneWords = ['done', 'finished', 'flip', 'switch', 'backs now', 'do backs', 'fronts now', 'do fronts'];

      const isCapture = captureWords.some(w => command.includes(w));
      const isDone = doneWords.some(w => command.includes(w));

      if (isCapture) {
        indicator.textContent = 'ðŸ“¸ Captured!';
        indicator.classList.add('show');
        setTimeout(() => indicator.classList.remove('show'), 800);
        capture();
      } else if (isDone && scanMode === 'bulk' && bulkPhase === 'fronts' && bulkFronts.length > 0) {
        indicator.textContent = 'âœ“ Switching to backs';
        indicator.classList.add('show');
        setTimeout(() => indicator.classList.remove('show'), 1000);
        finishFronts();
      } else if (isDone && scanMode === 'backsFirst' && backsFirstPhase === 'backs' && backsFirstBacks.length > 0) {
        indicator.textContent = 'âœ“ Flip stack & scan fronts!';
        indicator.classList.add('show');
        setTimeout(() => indicator.classList.remove('show'), 1500);
        finishBacks();
      } else {
        // Show what was heard for debugging
        indicator.textContent = `Heard: "${command}"`;
        indicator.classList.add('show');
        setTimeout(() => indicator.classList.remove('show'), 1200);
      }
    }

    // ============================================
    // SET SELECTION FUNCTIONS
    // ============================================

    // Popular sets with known parallels (matches server.js KNOWN_SET_PARALLELS keys)
    const POPULAR_SETS = [
      { set_name: 'Topps Chrome', sport: 'baseball' },
      { set_name: 'Bowman Chrome', sport: 'baseball' },
      { set_name: 'Topps', sport: 'baseball' },
      { set_name: 'Topps Heritage', sport: 'baseball' },
      { set_name: 'Bowman', sport: 'baseball' },
      { set_name: 'Prizm', sport: 'basketball' },
      { set_name: 'Select', sport: 'basketball' },
      { set_name: 'Mosaic', sport: 'basketball' },
      { set_name: 'Donruss Optic', sport: 'football' },
      { set_name: 'Panini Prizm', sport: 'football' },
    ];

    function showSetSelection() {
      document.getElementById('login-screen').style.display = 'none';
      document.getElementById('set-selection-screen').style.display = 'flex';
      document.getElementById('scanner').style.display = 'none';

      // Reset state
      selectedSetContext = null;
      document.getElementById('set-search-input').value = '';
      document.getElementById('set-results').innerHTML = '';
      document.getElementById('set-confirm-card').style.display = 'none';
      document.getElementById('btn-start-scanning').disabled = true;

      // Render popular sets grid
      const grid = document.getElementById('set-popular-grid');
      grid.innerHTML = POPULAR_SETS.map((s, i) =>
        `<button class="set-popular-btn" onclick="selectPopularSet(${i})">${s.set_name}</button>`
      ).join('');
      document.getElementById('set-popular').style.display = 'block';

      // Set up search input with debounce
      const input = document.getElementById('set-search-input');
      input.removeEventListener('input', handleSetSearchInput);
      input.addEventListener('input', handleSetSearchInput);
      input.focus();
    }

    function selectPopularSet(index) {
      const set = POPULAR_SETS[index];
      if (!set) return;
      // Put it in the search box and treat it like a custom set selection
      document.getElementById('set-search-input').value = set.set_name;
      document.getElementById('set-popular').style.display = 'none';
      document.getElementById('set-results').innerHTML = '';

      selectedSetContext = {
        set_name: set.set_name,
        year: null,
        sport: set.sport,
        parallels: []
      };

      // Show confirmation card
      document.getElementById('set-confirm-name').textContent = set.set_name;
      document.getElementById('set-confirm-meta').textContent = set.sport || '';
      document.getElementById('set-confirm-card').style.display = 'block';
      document.getElementById('btn-start-scanning').disabled = false;

      // Fetch parallels from backend (will hit hardcoded list)
      fetchAndShowParallels(set.set_name, null);
    }

    function handleSetSearchInput() {
      clearTimeout(setSearchTimeout);
      const query = document.getElementById('set-search-input').value.trim();
      if (query.length < 2) {
        document.getElementById('set-results').innerHTML = '';
        document.getElementById('set-popular').style.display = 'block';
        return;
      }
      document.getElementById('set-popular').style.display = 'none';
      setSearchTimeout = setTimeout(() => searchSets(query), 300);
    }

    async function searchSets(query) {
      const resultsEl = document.getElementById('set-results');
      resultsEl.innerHTML = '<div class="set-search-loading">Searching...</div>';

      try {
        const res = await fetch(`${API_URL}/sets/search?q=${encodeURIComponent(query)}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        const data = await res.json();

        // Always show "Use as typed" option so users can enter any set
        const typed = document.getElementById('set-search-input').value.trim();
        const useTypedHtml = `
          <div class="set-result-item" onclick="selectCustomSet()" style="border-color: rgba(0,246,255,0.25);">
            <div class="set-result-name" style="color: #00f6ff;">Use "${escapeHtml(typed)}"</div>
            <div class="set-result-meta">Enter as custom set name</div>
          </div>
        `;

        if (!data.sets || data.sets.length === 0) {
          resultsEl.innerHTML = useTypedHtml;
          window._setResults = [];
          return;
        }

        resultsEl.innerHTML = data.sets.map((s, i) => `
          <div class="set-result-item" onclick="selectSet(${i})">
            <div class="set-result-name">${escapeHtml(s.set_name)}</div>
            <div class="set-result-meta">
              ${s.year ? s.year + ' ' : ''}${s.sport ? '&middot; ' + s.sport : ''}${s.card_count ? ' &middot; ' + s.card_count + ' cards' : ''}
            </div>
          </div>
        `).join('') + useTypedHtml;

        // Store results for selection
        window._setResults = data.sets;
      } catch (e) {
        resultsEl.innerHTML = '<div class="set-search-loading">Search failed</div>';
      }
    }

    // Shared: fetch parallels and show in confirmation card
    async function fetchAndShowParallels(setName, year) {
      const parallelsEl = document.getElementById('set-confirm-parallels');
      parallelsEl.innerHTML = '<span style="color: rgba(255,255,255,0.4); font-size: 12px;">Loading parallels...</span>';

      try {
        const params = new URLSearchParams({ set: setName });
        if (year) params.append('year', year);
        const res = await fetch(`${API_URL}/sets/parallels?${params}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        const data = await res.json();

        if (data.parallels && data.parallels.length > 0) {
          selectedSetContext.parallels = data.parallels;
          parallelsEl.innerHTML = data.parallels.map(p =>
            `<span class="parallel-tag">${escapeHtml(p)}</span>`
          ).join('');
        } else {
          parallelsEl.innerHTML = '<span style="color: rgba(255,255,255,0.4); font-size: 12px;">No known parallels</span>';
        }
      } catch (e) {
        parallelsEl.innerHTML = '<span style="color: rgba(255,255,255,0.4); font-size: 12px;">Could not load parallels</span>';
      }
    }

    function showConfirmCard(setName, meta) {
      document.getElementById('set-confirm-name').textContent = setName;
      document.getElementById('set-confirm-meta').textContent = meta;
      document.getElementById('set-confirm-card').style.display = 'block';
      document.getElementById('set-results').innerHTML = '';
      document.getElementById('set-popular').style.display = 'none';
      document.getElementById('btn-start-scanning').disabled = false;
    }

    async function selectSet(index) {
      const set = window._setResults[index];
      if (!set) return;

      selectedSetContext = {
        set_name: set.set_name,
        year: set.year || null,
        sport: set.sport || null,
        parallels: []
      };

      showConfirmCard(set.set_name, (set.year ? set.year + ' ' : '') + (set.sport || ''));
      fetchAndShowParallels(set.set_name, set.year);
    }

    async function selectCustomSet() {
      const typed = document.getElementById('set-search-input').value.trim();
      if (!typed) return;

      const yearMatch = typed.match(/^(19|20)\d{2}\b/);
      const year = yearMatch ? yearMatch[0] : null;
      const setName = year ? typed.substring(year.length).trim() : typed;

      selectedSetContext = {
        set_name: setName || typed,
        year: year || null,
        sport: null,
        parallels: []
      };

      showConfirmCard(selectedSetContext.set_name, year || '');
      fetchAndShowParallels(selectedSetContext.set_name, year);
    }

    function skipSetSelection() {
      selectedSetContext = null;
      initScanner();
    }

    function confirmSetSelection() {
      if (!selectedSetContext) return;
      initScanner();
    }

    function openSetSelection() {
      // Re-open set selection from scanner (via badge tap)
      document.getElementById('scanner').style.display = 'none';
      showSetSelection();
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  </script>
</body>
</html>
